"""
3I/ATLAS proximity calculator (single-file)

What this script does
- Provides a simple Tkinter GUI to input date and time (day, month, year, hour, minute, second)
  using the Brasília timezone (America/Sao_Paulo).
- Queries JPL HORIZONS (via astroquery) for state vectors (x,y,z) of the interstellar comet 3I/ATLAS
  (designation: C/2025 N1) and for the solar-system planets at the requested instant.
- Computes heliocentric distances (in AU and km) and reports which planet the object is closest to at that
  time.
- Has a Reset button to clear inputs and run a new query.

Dependencies
- Python 3.9+
- tkinter (usually included in standard Python installers; on some Linux systems install python3-tk)
- pip install astroquery astropy tzdata
  (you may also install pytz if you prefer, but this script uses zoneinfo from the standard library)

Notes
- The code requires an internet connection because it queries JPL HORIZONS via astroquery.
- JPL/HORIZONS returns highly accurate ephemerides; results will therefore reflect the latest orbital solutions
  available at JPL.

Author: Generated by ChatGPT (assistance)
"""

import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime, timezone
from zoneinfo import ZoneInfo
from astropy.time import Time
from astroquery.jplhorizons import Horizons
import math

# Importações do Matplotlib
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

# Conversion constant
AU_TO_KM = 149597870.7

# Planet mapping: NAIF/HORIZONS major-body barycenter IDs (1..8)
PLANET_CODES = {
    'Mercury': 1,
    'Venus': 2,
    'Earth (EMB)': 3,
    'Mars': 4,
    'Jupiter': 5,
    'Saturn': 6,
    'Uranus': 7,
    'Neptune': 8,
    'Sun': 10, # Adicionando o Sol
}

class ProximityApp:
    def __init__(self, master):
        self.master = master
        master.title('3I/ATLAS proximity (C/2025 N1) - Brasília time')
        master.resizable(False, False)

        # Input frame
        frm = ttk.Frame(master, padding=12)
        frm.grid(row=0, column=0, sticky='nsew')

        # Date inputs (day, month, year)
        ttk.Label(frm, text='Day').grid(row=0, column=0)
        self.day_var = tk.StringVar(value=str(datetime.now(ZoneInfo('America/Sao_Paulo')).day))
        self.day = ttk.Entry(frm, width=5, textvariable=self.day_var)
        self.day.grid(row=1, column=0, padx=2)

        ttk.Label(frm, text='Month').grid(row=0, column=1)
        self.month_var = tk.StringVar(value=str(datetime.now(ZoneInfo('America/Sao_Paulo')).month))
        self.month = ttk.Entry(frm, width=5, textvariable=self.month_var)
        self.month.grid(row=1, column=1, padx=2)

        ttk.Label(frm, text='Year').grid(row=0, column=2)
        self.year_var = tk.StringVar(value=str(datetime.now(ZoneInfo('America/Sao_Paulo')).year))
        self.year = ttk.Entry(frm, width=8, textvariable=self.year_var)
        self.year.grid(row=1, column=2, padx=2)

        # Time inputs (hour, minute, second)
        ttk.Label(frm, text='Hour (0-23)').grid(row=2, column=0)
        self.hour_var = tk.StringVar(value=str(datetime.now(ZoneInfo('America/Sao_Paulo')).hour))
        self.hour = ttk.Entry(frm, width=5, textvariable=self.hour_var)
        self.hour.grid(row=3, column=0, padx=2)

        ttk.Label(frm, text='Minute').grid(row=2, column=1)
        self.minute_var = tk.StringVar(value=str(datetime.now(ZoneInfo('America/Sao_Paulo')).minute))
        self.minute = ttk.Entry(frm, width=5, textvariable=self.minute_var)
        self.minute.grid(row=3, column=1, padx=2)

        ttk.Label(frm, text='Second').grid(row=2, column=2)
        self.second_var = tk.StringVar(value='0')
        self.second = ttk.Entry(frm, width=8, textvariable=self.second_var)
        self.second.grid(row=3, column=2, padx=2)

        # Info label
        ttk.Label(frm, text='Timezone: America/Sao_Paulo (Brasília)').grid(row=4, column=0, columnspan=3, pady=(8,0))

        # Buttons
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=5, column=0, columnspan=3, pady=(8,0))

        self.calc_btn = ttk.Button(btn_frame, text='Calcular proximidade', command=self.calculate)
        self.calc_btn.grid(row=0, column=0, padx=8)

        self.reset_btn = ttk.Button(btn_frame, text='Resetar', command=self.reset)
        self.reset_btn.grid(row=0, column=1, padx=8)

        # Results area
        self.results = tk.Text(frm, width=72, height=14, wrap='word')
        self.results.grid(row=6, column=0, columnspan=3, pady=(10,0))
        self.results.insert('1.0', 'Resultados aparecerão aqui. Clique em "Calcular proximidade" para iniciar.\n')
        self.results.configure(state='disabled')

    def _set_results(self, text):
        self.results.configure(state='normal')
        self.results.delete('1.0', tk.END)
        self.results.insert('1.0', text)
        self.results.configure(state='disabled')

    def reset(self):
        now = datetime.now(ZoneInfo('America/Sao_Paulo'))
        self.day_var.set(str(now.day))
        self.month_var.set(str(now.month))
        self.year_var.set(str(now.year))
        self.hour_var.set(str(now.hour))
        self.minute_var.set(str(now.minute))
        self.second_var.set('0')
        self._set_results('Campos resetados. Insira nova data/hora e clique em "Calcular proximidade".')

    def calculate(self):
        # Disable button while running
        self.calc_btn.config(state='disabled')
        try:
            # parse input
            d = int(self.day_var.get())
            m = int(self.month_var.get())
            y = int(self.year_var.get())
            hh = int(self.hour_var.get())
            mm = int(self.minute_var.get())
            ss = int(self.second_var.get() or 0)

            # Build timezone-aware datetime in Brasília
            tz = ZoneInfo('America/Sao_Paulo')
            dt_local = datetime(y, m, d, hh, mm, ss, tzinfo=tz)

            # Convert to UTC for astropy/time handling
            dt_utc = dt_local.astimezone(timezone.utc)

            # Make an astropy Time object and get JD in TDB (required by many Horizons vector queries)
            t = Time(dt_utc, scale='utc')
            jd_tdb = t.tdb.jd

            self._set_results('Consultando JPL HORIZONS para a data (TDB JD = {:.6f})...\n'.format(jd_tdb))

            # Query the comet 3I/ATLAS (C/2025 N1) vectors relative to Solar-System Barycenter (@0)
            # Note: this requires internet access to contact the JPL Horizons service.
            comet = Horizons(id='C/2025 N1', id_type='designation', location='@0', epochs=jd_tdb)
            comet_vec = comet.vectors()
            # 'x', 'y', 'z' are returned in AU
            cx = float(comet_vec['x'][0])
            cy = float(comet_vec['y'][0])
            cz = float(comet_vec['z'][0])

            # Collect planet distances
            distances = []  # list of tuples (planet_name, distance_au)
            for pname, pid in PLANET_CODES.items():
                # request planet barycenter vector
                p = Horizons(id=str(pid), id_type='majorbody', location='@0', epochs=jd_tdb)
                pvec = p.vectors()
                px = float(pvec['x'][0])
                py = float(pvec['y'][0])
                pz = float(pvec['z'][0])

                dist_au = math.sqrt((cx-px)**2 + (cy-py)**2 + (cz-pz)**2)
                distances.append((pname, dist_au))

            # Sort by distance
            distances.sort(key=lambda x: x[1])

            nearest_name, nearest_au = distances[0]
            nearest_km = nearest_au * AU_TO_KM

            # Build output
            out_lines = []
            out_lines.append(f'Data e hora (Brasília): {dt_local.strftime("%Y-%m-%d %H:%M:%S %Z")})')
            out_lines.append('\nResultado:')
            out_lines.append(f'Objeto consultado: 3I/ATLAS (C/2025 N1)')
            out_lines.append(f'Planeta mais próximo nesse instante: {nearest_name}')
            out_lines.append('Distância: {:.6f} AU  (≈ {:.0f} km)'.format(nearest_au, nearest_km))
            out_lines.append('\nTabela de distâncias (AU):')
            for pname, dau in distances:
                out_lines.append('  - {:12s} : {:.6f} AU (≈ {:.0f} km)'.format(pname, dau, dau*AU_TO_KM))

            out = '\n'.join(out_lines)
            self._set_results(out)

        except Exception as e:
            messagebox.showerror('Erro', f'Ocorreu um erro:\n{e}')
            self._set_results('Erro ao executar a consulta. Verifique a conexão com a internet e os valores inseridos.')
        finally:
            self.calc_btn.config(state='normal')

if __name__ == '__main__':
    root = tk.Tk()
    app = ProximityApp(root)
    root.mainloop()

    
